// Package apiconfig loads and saves api tool configuration and state in TOML files.
package apiconfig

import (
	"bytes"
	"errors"
	"fmt"
	"io/fs"
	"log"
	"net/url"
	"os"
	"path/filepath"
	"strings"

	"github.com/pelletier/go-toml/v2"

	"bitbucket.org/classroomsystems/api-cli/opsecret"
)

type ErrNotFound struct {
	FileName string
}

func (e ErrNotFound) Error() string {
	return fmt.Sprintf("no %s found in any parent dir", e.FileName)
}

func Init(dst any, apiName string) *AuthState {
	auth, err := Load(dst, apiName)
	if err != nil {
		log.Fatalln(err)
	}
	return auth
}

func Load(dst any, apiName string) (*AuthState, error) {
	name := "api.config"
	if apiName != "" {
		name = "api-" + apiName + ".config"
	}
	f, err := openConfig(name)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	err = toml.NewDecoder(f).Decode(dst)
	if err != nil {
		return nil, fmt.Errorf("apiconfig.Load: %s: %w", f.Name(), err)
	}
	auth := &AuthState{
		FileName: strings.TrimSuffix(f.Name(), ".config") + ".auth",
		Values:   make(map[string]string),
	}
	err = auth.Load()
	if err != nil {
		return nil, fmt.Errorf("apiconfig.Load: %s: %w", auth.FileName, err)
	}
	return auth, nil
}

func Deref(val string) (string, error) {
	if !strings.HasPrefix(val, "{{") || !strings.HasSuffix(val, "}}") {
		return val, nil
	}
	val = val[2 : len(val)-2]
	switch {
	case strings.HasPrefix(val, "op://"):
		return opsecret.Get(val)
	default:
		return val, fmt.Errorf("apiconfig: bad parameter reference: {{%s}}", val)
	}
}

func openConfig(name string) (*os.File, error) {
	parent, err := os.Getwd()
	if err != nil {
		return nil, err
	}
	for {
		f, err := os.Open(filepath.Join(parent, name))
		if err == nil {
			return f, err
		}
		d := filepath.Dir(parent)
		if len(d) >= len(parent) {
			return nil, ErrNotFound{name}
		}
		parent = d
	}
}

type AuthState struct {
	FileName string
	Values   map[string]string
}

func (a *AuthState) Load() error {
	f, err := os.Open(a.FileName)
	if errors.Is(err, fs.ErrNotExist) {
		// Non-existent is just treated as empty.
		return nil
	}
	if err != nil {
		return err
	}
	err = toml.NewDecoder(f).Decode(&a.Values)
	return err
}

func (a *AuthState) Save() error {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, "# Do not edit this file: it is automatically generated.")
	err := toml.NewEncoder(&buf).Encode(a.Values)
	if err != nil {
		return err
	}
	return os.WriteFile(a.FileName, buf.Bytes(), 0600)
}

/*
Dereffer eases error handling when dereferencing many values at once.

	original := &someStruct{
		Foo: "{{ref:Something}}",
		Bar: "Whatever",
		Baz: []string{
			"{{ref:something-else}}",
			"literal",
		},
	}
	var deref apiconfig.Dereffer
	return &SomeStruct{
		Foo: deref.String(original.Foo),
		Bar: deref.String(original.Bar),
		Baz: deref.StringSlice(original.Baz),
	}, deref.Error
*/
type Dereffer struct {
	Error error
}

func (d *Dereffer) String(s string) string {
	if d.Error != nil {
		return ""
	}
	s, d.Error = Deref(s)
	return s
}

func (d *Dereffer) StringSlice(s []string) []string {
	if s == nil {
		return nil
	}
	s2 := make([]string, len(s))
	for i := range s {
		s2[i] = d.String(s[i])
	}
	return s2
}

func (d *Dereffer) StringMap(m map[string]string) map[string]string {
	if m == nil {
		return nil
	}
	m2 := make(map[string]string, len(m))
	for k, v := range m {
		m2[k] = d.String(v)
	}
	return m2
}

func (d *Dereffer) URLValues(vals url.Values) url.Values {
	if vals == nil {
		return nil
	}
	vals2 := make(url.Values, len(vals))
	for k, v := range vals {
		vals2[k] = d.StringSlice(v)
	}
	return vals2
}
